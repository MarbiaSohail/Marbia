"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.convertPackageNameToProjectName = exports.resolveModuleAsync = exports.generatePackageListAsync = void 0;
const fast_glob_1 = __importDefault(require("fast-glob"));
const fs_extra_1 = __importDefault(require("fs-extra"));
const path_1 = __importDefault(require("path"));
/**
 * Generates Java file that contains all autolinked packages.
 */
async function generatePackageListAsync(modules, targetPath, namespace) {
    const generatedFileContent = await generatePackageListFileContentAsync(modules, namespace);
    await fs_extra_1.default.outputFile(targetPath, generatedFileContent);
}
exports.generatePackageListAsync = generatePackageListAsync;
async function findGradleFilesAsync(revision) {
    const configGradlePaths = revision.config?.androidGradlePaths();
    if (configGradlePaths && configGradlePaths.length) {
        return configGradlePaths;
    }
    const buildGradleFiles = await (0, fast_glob_1.default)('*/build.gradle', {
        cwd: revision.path,
        ignore: ['**/node_modules/**'],
    });
    return buildGradleFiles;
}
async function resolveModuleAsync(packageName, revision) {
    // TODO: Relative source dir should be configurable through the module config.
    // Don't link itself... :D
    if (packageName === '@unimodules/react-native-adapter') {
        return null;
    }
    const buildGradleFiles = await findGradleFilesAsync(revision);
    // Just in case where the module doesn't have its own `build.gradle`.
    if (!buildGradleFiles.length) {
        return null;
    }
    const projects = buildGradleFiles.map((buildGradleFile) => {
        const gradleFilePath = path_1.default.join(revision.path, buildGradleFile);
        return {
            name: convertPackageNameToProjectName(packageName, path_1.default.relative(revision.path, gradleFilePath)),
            sourceDir: path_1.default.dirname(gradleFilePath),
        };
    });
    const plugins = (revision.config?.androidGradlePlugins() ?? []).map(({ id, group, sourceDir }) => ({
        id,
        group,
        sourceDir: path_1.default.join(revision.path, sourceDir),
    }));
    return {
        packageName,
        projects,
        ...(plugins.length > 0 ? { plugins } : {}),
        modules: revision.config?.androidModules() ?? [],
    };
}
exports.resolveModuleAsync = resolveModuleAsync;
/**
 * Generates the string to put into the generated package list.
 */
async function generatePackageListFileContentAsync(modules, namespace) {
    // TODO: Instead of ignoring `expo` here, make the package class paths configurable from `expo-module.config.json`.
    const packagesClasses = await findAndroidPackagesAsync(modules.filter((module) => module.packageName !== 'expo'));
    const modulesClasses = await findAndroidModules(modules);
    return `package ${namespace};

import java.util.Arrays;
import java.util.List;
import e